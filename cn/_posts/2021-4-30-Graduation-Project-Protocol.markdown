---
lng_pair: UN4_GP_NT
title: 局域网通信协议设计
author: 张靖祥
category: 课程项目
tags: [Python, 计算机网络]
img: ":UN_4_GP_NP/sketch_front.png"
date: 2021-04-30 00:00:00
---

### 项目介绍

在学习了自组织网络，路由器上运行的OSPF和RIP协议，应用层的MQTT和HTTP协议之后，我对网络协议非常感兴趣，而那时我正在做我的毕业设计。因此，我决定设计自己的协议，作为毕业设计的附加部分。<!-- outline-start -->该协议我将其命名为局域网通信协议，用于在设计之间进行函数调用，并用Python语言实现了该协议。<!-- outline-end -->  （我本应该用C或者c++来实现，因为效率比较高，但是我当时很忙。所以我必须使用Python）

### 背景介绍

在我的毕业设计中，我需要在局域网（LAN）上传输数据和命令，以控制其他设备。如果中央服务器是一台高性能的计算机，而用户的计算机是一台低性能的计算机，作为一个用户，我想执行一个繁重的计算命令，我将需要将我的python代码复制到服务器，并在服务器端运行它。所以我想把这个功能提前放在服务器上，这样局域网上的任何人任何设备都可以方便地调用这个功能。

![示意图](:UN_4_GP_NP/sketch.png){:data-align="center"}

例如，在上图中，设备A有一个计算型的函数A，设备B或C可以通过一行代码调用函数A。

在继续之前，我必须承认这不是一个普遍的问题。即使局域网中的许多设备需要相互传输数据，它们也可以有许多其他的解决方案。但在这里，我只想提出我的解决方案。我已经在pipy中上传了这个，它可以通过“pip -install lancommunication”安装

协议的执行顺序图如下所示。当设备A和设备B都启用该协议时，设备A首先注册功能F。此时设备B可以接收到设备A在局域网内的地址，执行功能F并存储在功能表中。设备B使用调用函数调用F时，只需要传入函数名“F”和相应的参数即可完成函数调用。

![时序图](:UN_4_GP_NP/sequence.png){:data-align="center"}

该函数为非阻塞函数，即调用该函数后程序可以继续执行，但不会得到执行结果，因为需要在另一个设备上执行。'call'函数返回一个exe_id作为函数的执行ID号，用于读取执行结果。设备B可以使用'join'方法传入一个exe_id号并阻塞线程，直到函数F的执行完成，以确保调用函数F的设备B能够获得执行结果。

最后，使用'get'函数来获取执行结果，传入exe_id号来获取执行结果。注意，如果你在设备A返回结果之前使用'get'函数，你将得到一个错误消息，表明结果还没有得到。

### 协议细节

本协议共有9个字段：

| 编号 | 字段名 | 含义 | 取值 |
| :------: | :------: | :------: | :------: |
| 1 | type | 协议类型 | LANC |
| 2 | method | 协议方法 | hello, func, call, callback |
| 3 | version | 当前版本号 | 0.1 |
| 4 | data | 传输的数据 |  |
| 5 | exe_id | 执行id |  |
| 6 | args | 函数参数 |  |
| 7 | kwargs | 函数参数 |  |
| 8 | encrypted |  | no |
| 9 | compress |  | no |
{:data-align="center"}

- 协议使用的传输端口号默认为5127，可以在配置文件中修改。
- 协议方法包括一个Hello方法通知其他设备它的地址，func方法用于通知其他设备它可以执行的函数，call方法用于调用另一个设备上的函数（或可以调用自己的函数），和callback方法返回函数的执行结果。
- data表示要传输的具体数据，仅当协议方法为func和callback时使用，其中func方法表示可执行函数名列表，callback方法表示函数执行结果。
- Exe_id用于表示该函数的执行ID。例如，当设备A调用设备B的F函数时，设备A会生成一个exe_id来记录这个过程。该ID在调用调用方法时被发送给设备B，在函数执行后返回结果给设备A时附加一个ID号。用于唯一确定执行过程。
- Args和kwargs表示函数的参数传递，只包含在调用方法中，用于将函数的参数传递给被调用的设备。
- Encrypted和compress分别表示数据加密类型和数据压缩类型。该模块作为可扩展内容，本研究暂未实现。
- 数据以JSON格式发送，方便数据处理。

#### Hello方法

(1) Hello方法发送

设备上线后，每隔几秒向该网段上所有设备的5127端口广播一次，启动一个独立的线程被用来发送数据包。

(2) Hello方法接收

设备接收到其他设备发送的Hello方法报文后，会与自己维护的设备表进行比较。如果已经收到设备的IP地址，则更新设备向该IP地址发送最近一次Hello报文的时间。如果第一次收到该设备的地址，或者发现该设备的上一个Hello报文已经过期，它会立即向该设备发送一个Hello报文来表明它的存在，然后发送一个Func报文。用于通知设备可以执行的函数名列表。

局域网中的任何设备上线后，它都会广播hello报文。所有使用LANCommunicate协议的设备都会将报文记录在自己的设备列表中，并向设备发送相同的hello报文和自己可以执行的功能列表。设备接收来自其他设备的信息以及可执行的功能列表，局域网中的任何两个设备现在都可以知道对方的地址。
 
#### Func方法

(1) Func方法发送

当在设备A上使用寄存器功能时，它会向局域网广播函数名。例如，当注册'add'函数时，它会先在本地服务字典中存储'add'函数，然后在局域网中广播'add'函数名。

Func方法是非阻塞的，它会首先向用户承诺广播该函数，并将其放入等待列表中，然后等待1秒。在这一秒，如果你注册了另一个函数，它会存储在等待列表中，然后，等待列表中会有2个函数。它将继续在等待列表中存储函数名，直到1秒内没有函数进入列表。此时，所有函数名都将作为列表发送(这里，我受到TCP协议的启发)。

(2) Func方法接收

当协议接收到函数名列表时，它将其添加到外围服务字典中，其中键是函数名，值是函数执行地址。当从不同的设备接收到具有相同函数名的函数时，执行地址将被覆盖。当一个函数被调用时，设备只执行与最后接收到的函数名对应的地址。

#### Call方法

(1) Call方法发送

Call类型用于发送在其他设备上执行的函数的信息。当用户调用一个函数时，协议将函数名与本地服务列表进行比较。如果用户调用的函数是本地业务函数，则不发送Call报文直接调用该函数。如果在另一个设备上执行，用户发送的函数参数被打包到args和kwargs条目中以供发送。返回exe_id id给用户获取执行结果。exe_id也会随协议报文一起发送到功能执行设备。

(2) Call方法接收

当协议接收到调用消息时，它启动一个单独的执行线程，搜索本地服务列表，调用相关函数，并返回函数的执行结果。执行结果作为回调发送。

#### Callback方法

(1) Callback方法发送

在被调用的设备执行该函数之后，执行结果会被打包，并附带exe_id的值，然后作为'callback'类型发送。

(2) Callback方法接收

接收到callback类型的数据后，接收方将其存储在函数调用结果字典中，其中键是exe_id，值是函数的返回值。调用函数的线程将被解除阻塞，以确保用户能够获得函数执行的结果。

### 使用Python实现该协议

#### 项目架构

类的继承关系图见4-3所示，其中核心部分的NatConnector继承了数据的发送Transmit基类与数据的接收Receiver基类。其余的功能分别为用于存储静态变量的static模块、用于提供额外的网络功能的net_tools模块、用于错误处理的LANException模块。

![类继承关系](:UN_4_GP_NP/class.png){:data-align="center"}

项目主架构：

![主架构](:UN_4_GP_NP/structure.png){:data-align="center"}

#### 数据包

通过wireshark捕捉的数据包如下：

![数据包](:UN_4_GP_NP/datagram.png){:data-align="center"}

### 可扩展功能

本协议目前为0.1版本，尚有许多不完善的地方，但限于时间关系，本文没有完成，并将其总结如下：
- 数据加密：在最后数据传输前加一个数据加密处理，可以采用目前主流的对称加密算法AES，或非对称加密算法RSA等；
- 数据压缩：将data数据进行压缩后再传输；
- 数据传输采用稳定的tcp协议，由函数调用方提前打开空闲的tcp端口，将该内容与函数调用信息发送给函数被调用方，函数执行方通过tcp端口，将函数执行的数据传输，之后关闭tcp端口；
- 接受数据后加入到任务队列，然后从队列里取数据执行，解决高并发问题；
- call函数加入一个回调函数机制，可以在执行完call后自动调用一个回调函数，解决只能通过join阻塞获取函数执行结果的问题；
- join函数设定最高等待时间，防止进程卡死。等待时间到达则直接raise一个错误
- 制定出错后产生的错误协议，可以类似于ICMP协议；
- 加入loop_forever函数，永远阻塞，适用于服务器专门执行用户的函数；
- 运用多进程，因为python的GIL锁机制，多线程只能用一个CPU核心，只能采用多进程以提高性能；
- 消息支持发送到其他网段，实现跨网段的函数调用
- 支持一个函数可以多个服务器同时执行，只获取最快的结果

点击[此处](https://github.com/Jingxiang-Zhang/LAN-Communication-Protocol)查看项目源代码
